""" Functions used for running the acquisition of kinematics """

import videotools as vt
import os
import pandas as pd
import numpy as np

def report_version():

    print("v.6")

def get_cat_info(cat_path, include_mode='both'):
    """ Extracts key parameters from experiment catalog for making videos from image sequence.
    Videos included are the ones where analyze==1 and make_video==1.

    Column names must include 'date', 'trial_num', 'analyze', and 'make_video'
    
    cat_path:  Full path to video catalog (CSV file)
    include_mode: Criteria for what to include. Can be 'analyze', 'make_video', or 'both'

    """

    # Open CSV file
    file = open(cat_path)

    # Import CSV data
    d = pd.read_csv(file)

    # Determine which rows to include
    if include_mode=='both':
        d = d.loc[(d.analyze == 1) & (d.make_video == 1)]

    elif include_mode=='analyze':
        d = d.loc[(d.analyze == 1)]
        
    elif include_ode=='make_video':
        d = d.loc[(d.make_video == 1)]

    # Reset indices for the new rows
    d = d.reset_index(drop=True)

    return d


def make_videos(df, im_path, vid_path, vmode=False, vertpix=None, suffix_in='JPG', suffix_out='mp4', ndigits=5, prefix='DSC', imquality=0.35):
    """ Uses videotools to create videos from the image sequences from the experiments 
    
    df: dataframe generated by get_cat_info with the info needed for each video where analyze==1 and make_video==1.
    im_path: Root directory that holds the directories named for the date of the experiment.
    vid_path: Path to directory where videos will be saved.
    vmode: Verbose mode shows more output (from ffmpeg).
    vertpix: Number of pixels in verical dimension, if downsampling. Set to None, if full resolution.
    suffix_in: Suffix for source images or movies.
    suffix_out: Suffix for output movies
    ndigits: Number of digits in input image filenames
    prefix: Prefix at the start of each image filename
    imquality: Image quality (low to high: 0 to 1) for output video
    """

    # Loop thru each video listed in df
    for c_row in df.index:

        # String for experiment number
        exp_num = '0' + str(df.exp_num[c_row])

        # Paths for current output and input videos
        vid_outpath = vid_path + os.sep + df.date[c_row] + '_' + exp_num[-2:] + '.' + suffix_out
        image_path = im_path + os.sep + df.date[c_row]

        # Read number of frames from spreadsheet
        fr_start = int(df.start_imagename[c_row][len(prefix):])
        fr_end = int(df.end_imagename[c_row][len(prefix):])


        # Match output with input frame rate
        fps = df.fps[c_row]

        # Define ROI, if needed
        roi_x = df.roi_x[c_row]
        roi_y = df.roi_y[c_row]
        roi_w = df.roi_w[c_row]
        roi_h = df.roi_h[c_row]

        if not (roi_x == 'nan'):
            r = [int(float(roi_x)), int(float(roi_y)), int(float(roi_w)), int(float(roi_h))]
        else:
            r = None

        # Create movie
        vt.vid_from_seq(image_path, vid_outpath, frStart=fr_start, frEnd=fr_end, fps=fps, imQuality=imquality,
                        prefix=prefix, nDigits=ndigits, inSuffix=suffix_in, vertPix=vertpix,
                        roi=r, vMode=vmode)

        # Report counter
        print('Finished with ' + str(c_row + 1) + ' of ' + str(len(df)) + ' videos.')


def convert_videos(df, in_path, out_path, out_name=None, vmode=True, vertpix=None, imquality=1, 
                   suffix_in='MOV', suffix_out='mp4', para_mode=False, echo=True, border_pix=None):
    """ Uses videotools to convert videos from experiments

    df: dataframe generated by get_cat_info with the info needed for each video where analyze==1 and make_video==1.
    in_path: Path to input video file (without suffix).
    out_path: Path to output file (without suffix).
    out_name: File name of output file
    vmode: Verbose mode shows more output (from ffmpeg)
    imquality: Image quality (low to high: 0 to 1) for output video
    suffix_in: Suffix for source images or movies
    suffix_out: Suffix for output movies
    vertpix: Size of video frames in vertical pixels 
    para_mode: Whether to run parallel processing (requires additional code)
    echo: Whether to print the steps as they are executed
    pix_extra: Number of pixels to include around the roi
    """

    if para_mode:
        # Set up empty dataframe for parallel processing of ffmpeg commands
        cmds = pd.DataFrame(columns=['command'])

    # Loop thru each video listed in df
    for c_row in df.index:

        if border_pix is not None:
            # Define ROI without extra
            roi_x = df.roi_x[c_row] - int(np.ceil(border_pix))
            roi_y = df.roi_y[c_row] - int(np.ceil(border_pix))
            roi_w = df.roi_w[c_row] + int(np.ceil(2*border_pix))
            roi_h = df.roi_h[c_row] + int(np.ceil(2*border_pix))
        else:
            # Define ROI without extra
            roi_x = df.roi_x[c_row]
            roi_y = df.roi_y[c_row]
            roi_w = df.roi_w[c_row]
            roi_h = df.roi_h[c_row]

        if not (roi_x == 'nan'):
            r = [int(float(roi_x)), int(float(roi_y)), int(float(roi_w)), int(float(roi_h))]
        else:
            r = None

        # Overwrite vertpix
        vertpix=None

        # Total input path (video dir path + filename)
        tot_in_path = in_path + os.sep + df.video_filename[c_row] + '.' + suffix_in

        # Total output path (video dir path + filename)
        if out_name is None:
            tot_out_path = out_path + os.sep + df.video_filename[c_row] + '.' + suffix_out
            # tot_out_path = out_path + os.sep + os.path.splitext(os.path.basename(in_path))[0] + '.' + suffix_out
        else:
            tot_out_path = out_path + os.sep + out_name + '.' + suffix_out

        # Check for source video
        if not os.path.isfile(tot_in_path):
            raise OSError('Video file does not exist: ' + tot_in_path)

        # Check for output directory
        if not os.path.isdir(out_path):
            raise OSError('Output directory does not exist: ' + out_path)

        # Update status
        if echo:
            print('Converting video ' + str(c_row+1) + ' of ' + str(len(df)))

        # Create movie
        cmd = vt.vid_convert(tot_in_path, tot_out_path, imQuality=imquality, vertPix=vertpix,
                       roi=r, vMode=vmode, para_mode=para_mode, echo=echo)

        if para_mode:
            cmds_c = pd.DataFrame([[cmd]],
                                columns=['command'])

            # Add to dataframe
            cmds = pd.concat([cmds, cmds_c], sort=False, ignore_index=True)

        else:
            cmds = cmd

        # Report counter
        if echo:
            print('Finished with ' + str(c_row + 1) + ' of ' + str(len(df)) + ' videos.')

    return cmds

def convert_masked_videos(df, in_path, out_path, maskpath, out_name=None, vmode=True, imquality=1, 
                          suffix_in='MOV', suffix_out='mp4', para_mode=False, echo=True):
    """ Uses videotools to convert videos from experiments

    df: dataframe generated by get_cat_info with the info needed for each video where analyze==1 and make_video==1.
    in_path: Path to input video file (without suffix).
    out_path: Path to output file (without suffix).
    out_name: File name of output file
    vmode: Verbose mode shows more output (from ffmpeg)
    imquality: Image quality (low to high: 0 to 1) for output video
    suffix_in: Suffix for source images or movies
    suffix_out: Suffix for output movies
    maskpath: Directory path for the mask image files
    para_mode: Whether to run parallel processing (requires additional code)
    echo: Whether to print the steps as they are executed
    """
    
    if para_mode:
        # Set up empty dataframe for parallel processing of ffmpeg commands
        cmds = pd.DataFrame(columns=['command'])

    # Loop thru each video listed in df
    for c_row in df.index:

        # Total input path (video dir path + filename)
        tot_in_path = in_path + os.sep + df.video_filename[c_row] + '.' + suffix_in

        # Total output path (video dir path + filename)
        if out_name is None:
            tot_out_path = out_path + os.sep + df.video_filename[c_row] + '.' + suffix_out
            # tot_out_path = out_path + os.sep + os.path.splitext(os.path.basename(in_path))[0] + '.' + suffix_out
        else:
            tot_out_path = out_path + os.sep + out_name + '.' + suffix_out

        # Total mask path 
        tot_mask_path = maskpath + os.sep + df.mask_filename[c_row] + '.png'

        if echo:
            # Update status
            print('Converting video ' + str(c_row+1) + ' of ' + str(len(df)))

        # Check for mask path
        if not os.path.isfile(tot_mask_path):
            raise OSError('Mask file does not exist: ' + tot_mask_path)

        # Check for source video
        if not os.path.isfile(tot_in_path):
            raise OSError('Video file does not exist: ' + tot_in_path)

        # Check for output directory
        if not os.path.isdir(out_path):
            raise OSError('Output directory does not exist: ' + out_path)

        # Create movie
        cmd = vt.vid_convert(tot_in_path, tot_out_path, imQuality=imquality, vMode=vmode, 
                             maskpath=tot_mask_path, para_mode=para_mode, echo=echo)

        if para_mode:
            cmds_c = pd.DataFrame([[cmd]],
                                columns=['command'])

            # Add to dataframe
            cmds = pd.concat([cmds, cmds_c], sort=False, ignore_index=True)
        else:
            cmds = cmd

        if echo:
            # Report counter
            print('Finished with ' + str(c_row + 1) + ' of ' + str(len(df)) + ' videos.')

    return cmds
    # Execute ffmpeg using the parallel processing
    # if parallel_mode:

    #     import time
    #     import ipyparallel as ipp
    #     import sys

    #     # Report python and IPyparallel versions to make sure they exist
    #     # print("Python Version : ", sys.version)
    #     # print("IPyparallel Version : ", ipp.__version__)

    #     # Set up clients 
    #     client = ipp.Client()
    #     type(client), client.ids

    #     # Direct view allows shared data (balanced_view is the alternative)
    #     direct_view = client[:]

    #     # Function to execute the code
    #     def slow_power(idx):
    #         import os
    #         os.system(cmds_run.command[idx])
    #         return idx

    #     direct_view["cmds_run"] = cmds

    #     res = []
    #     for n in range(len(direct_view)):
    #         res.append(client[n].apply(slow_power, n))

    #     [r.result() for r in res]

# def batch_command(cmds):
#     # import time
#     import ipyparallel as ipp
#     import sys

#     # Report python and IPyparallel versions to make sure they exist
#     # print("Python Version : ", sys.version)
#     # print("IPyparallel Version : ", ipp.__version__)

#     # Set up clients 
#     client = ipp.Client()
#     type(client), client.ids

#     # Direct view allows shared data (balanced_view is the alternative)
#     direct_view = client[:]

#     # Function to execute the code
#     def run_command(idx):
#         import os
#         os.system(cmds_run.command[idx])
#         return idx

#     direct_view["cmds_run"] = cmds

#     res = []
#     for n in range(len(direct_view)):
#         res.append(client[n].apply(run_command, n))